#!/bin/bash

# KDE Auto-rotation script for Chuwi Minibook X
# Monitors accelerometer and rotates screen based on device orientation
# Based on working configuration from KDE_Autorotation_Setup_Instructions.txt
# 
# ULTRA-LOW SENSITIVITY CONFIGURATION:
# - Requires significant movement (~15-20 degrees) to trigger rotation
# - Uses hysteresis to prevent rapid switching between orientations
# - Requires 7 consecutive stable readings (1.4+ seconds) before rotation
# - Prevents accidental rotations from small movements

# Configuration
ACCEL_DEVICE="/sys/bus/iio/devices/iio:device0"
SCALE=$(cat "$ACCEL_DEVICE/in_accel_scale" 2>/dev/null || echo "0.0009765625")
THRESHOLD=2.5  # Sensitivity threshold for rotation detection (ultra-low sensitivity - requires ~15-20 degrees movement)
HYSTERESIS_THRESHOLD=1.8  # Lower threshold for switching back (prevents rapid switching between orientations)
ORIENTATION_OFFSET=0  # No offset - direct accelerometer reading (working config)
CURRENT_ROTATION=""
DISPLAY_NAME="DSI-1"  # Chuwi Minibook X display name
STABLE_COUNT=0  # Counter for stable readings before changing rotation
STABLE_THRESHOLD=7  # Number of consecutive stable readings required (about 1.4 seconds delay)

# Function to get current rotation value
get_current_rotation() {
    kscreen-doctor -o | grep "Rotation:" | awk '{print $2}' 2>/dev/null || echo "none"
}

# Function to set rotation
set_rotation() {
    local rotation=$1
    echo "Setting rotation to: $rotation"
    kscreen-doctor "output.$DISPLAY_NAME.rotation.$rotation" 2>&1
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        echo "Warning: kscreen-doctor failed with exit code $exit_code"
        echo "Display: $DISPLAY_NAME, Rotation: $rotation"
    fi
}

# Function to read accelerometer values
read_accelerometer() {
    local x_raw=$(cat "$ACCEL_DEVICE/in_accel_x_raw" 2>/dev/null || echo "0")
    local y_raw=$(cat "$ACCEL_DEVICE/in_accel_y_raw" 2>/dev/null || echo "0")
    local z_raw=$(cat "$ACCEL_DEVICE/in_accel_z_raw" 2>/dev/null || echo "0")
    
    # Convert to actual values using scale
    local x=$(echo "$x_raw * $SCALE" | bc -l)
    local y=$(echo "$y_raw * $SCALE" | bc -l)
    local z=$(echo "$z_raw * $SCALE" | bc -l)
    
    echo "$x $y $z"
}

# Function to determine orientation with hysteresis
determine_orientation() {
    local x=$1
    local y=$2
    local z=$3
    local current_orientation=$4
    
    # Apply orientation offset (similar to GNOME's setting)
    if [ "$ORIENTATION_OFFSET" = "1" ]; then
        # Offset by 90 degrees clockwise
        local temp=$x
        x=$y
        y=$(echo "-$temp" | bc -l)
    elif [ "$ORIENTATION_OFFSET" = "2" ]; then
        # Offset by 180 degrees
        x=$(echo "-1 * $x" | bc -l)
        y=$(echo "-1 * $y" | bc -l)
    elif [ "$ORIENTATION_OFFSET" = "3" ]; then
        # Offset by 90 degrees counter-clockwise
        local temp=$x
        x=$(echo "-1 * $y" | bc -l)
        y=$temp
    fi
    
    # Determine orientation based on accelerometer values with hysteresis
    # Working configuration for Chuwi Minibook X:
    # X positive → "left" rotation
    # X negative → "right" rotation  
    # Y positive → "inverted" rotation
    # Y negative → "none" rotation
    
    # Use different thresholds based on current orientation (hysteresis)
    local threshold_to_use=$THRESHOLD
    if [ -n "$current_orientation" ] && [ "$current_orientation" != "none" ]; then
        threshold_to_use=$HYSTERESIS_THRESHOLD
    fi
    
    local x_gt_threshold=$(echo "$x > $threshold_to_use" | bc -l)
    local x_lt_neg_threshold=$(echo "$x < -$threshold_to_use" | bc -l)
    local y_gt_threshold=$(echo "$y > $threshold_to_use" | bc -l)
    local y_lt_neg_threshold=$(echo "$y < -$threshold_to_use" | bc -l)
    
    if [ "$x_gt_threshold" = "1" ]; then
        echo "left"
    elif [ "$x_lt_neg_threshold" = "1" ]; then
        echo "right"
    elif [ "$y_gt_threshold" = "1" ]; then
        echo "inverted"
    elif [ "$y_lt_neg_threshold" = "1" ]; then
        echo "none"
    else
        echo "none"  # Default to normal orientation
    fi
}

# Check if accelerometer is available
if [[ ! -f "$ACCEL_DEVICE/in_accel_x_raw" ]]; then
    echo "Error: Accelerometer device not found at $ACCEL_DEVICE"
    echo "Please ensure iio-sensor-proxy is running and accelerometer is available"
    exit 1
fi

# Main loop
echo "KDE Auto-rotation started for Chuwi Minibook X"
echo "Monitoring accelerometer: $ACCEL_DEVICE"
echo "Display: $DISPLAY_NAME"
echo "Orientation offset: $ORIENTATION_OFFSET"
echo "Threshold: $THRESHOLD (hysteresis: $HYSTERESIS_THRESHOLD)"
echo "Stability requirement: $STABLE_THRESHOLD consecutive readings (~1.4 seconds)"
echo "Check interval: 0.2 seconds"
echo ""
echo "ULTRA-LOW SENSITIVITY MODE:"
echo "- Requires significant movement (~15-20 degrees) to trigger rotation"
echo "- Small movements (1-8 degrees) are completely ignored"
echo "- Deliberate rotations must be held for ~1.4 seconds before screen rotates"
echo "- Prevents accidental rotations from minor device movements"
echo ""
echo "Press Ctrl+C to stop"
echo ""

while true; do
    # Read accelerometer values
    read x y z <<< $(read_accelerometer)
    
    # Determine orientation with hysteresis
    orientation=$(determine_orientation "$x" "$y" "$z" "$CURRENT_ROTATION")
    
    # Check if orientation has changed
    if [ "$orientation" != "$CURRENT_ROTATION" ]; then
        # Increment stable count for new orientation
        STABLE_COUNT=$((STABLE_COUNT + 1))
        
        # Only change rotation after stable readings
        if [ $STABLE_COUNT -ge $STABLE_THRESHOLD ]; then
            echo "$(date): Rotating to $orientation (x=$x, y=$y, z=$z) [stable for $STABLE_COUNT readings]"
            set_rotation "$orientation"
            CURRENT_ROTATION="$orientation"
            STABLE_COUNT=0  # Reset counter after successful rotation
        else
            echo "$(date): Detected $orientation but waiting for stability (x=$x, y=$y, z=$z) [stable: $STABLE_COUNT/$STABLE_THRESHOLD]"
        fi
    else
        # Reset stable count if orientation hasn't changed
        STABLE_COUNT=0
    fi
    
    # Sleep for a short interval
    sleep 0.2
done
